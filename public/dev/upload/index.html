<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>SyndiNet - Upload</title>
  <link rel="icon" type="image/jpeg" href="/favicon.jpg">

  <!-- Uppy CSS -->
  <link href="https://releases.transloadit.com/uppy/v4.18.2/uppy.min.css" rel="stylesheet">

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #333;
      background-color: #f8f9fa;
      margin: 0;
      padding: 0;
    }

    .button-link {
      display: inline-block;
      padding: 0.5rem 1rem;
      margin: 1rem;
      background-color: white;
      color: #3498db;
      text-decoration: none;
      border-radius: 4px;
      border: 1px solid #3498db;
      font-weight: 500;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .button-link:hover {
      background-color: #f8f9fa;
    }

    .upload-status {
      padding: 1rem;
      margin: 1rem;
      border-radius: 4px;
      display: none;
    }

    .upload-status.success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .upload-status.error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    #uppy-container {
      position: fixed;
      top: 65px;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: calc(100% - 65px);
      z-index: 5000;
      background: #fff;
      display: flex;
      flex-direction: column;
    }

    .uppy-Dashboard,
    .uppy-Dashboard-inner {
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
      max-height: none !important;
    }

    .uppy-Dashboard-inner {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    .uppy-Root {
      flex: 1;
    }

    .uppy-Dashboard-dropFilesHereHint,
    .uppy-Dashboard-AddFiles-title {
      font-size: 1rem;
      font-weight: 500;
      color: #333;
    }

    .uppy-Dashboard-Item-previewInnerWrap {
      padding: 30px;
    }

    .uppy-Dashboard--singleFile .uppy-Dashboard-Item {
      height: fit-content;
    }

    @media (max-width: 600px) {
      .button-link {
        width: 100%;
        text-align: center;
        box-sizing: border-box;
      }
    }
  </style>

  <!-- Clerk JS -->
  <script defer crossorigin="anonymous" data-clerk-publishable-key="pk_live_Y2xlcmsuc3luZGluZXQuY29tJA"
    src="https://clerk.syndinet.com/npm/@clerk/clerk-js@5/dist/clerk.browser.js" type="text/javascript">
    </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js"></script>
</head>

<body>
  <div id="uppy-container"></div>
  <a href="/dev/index.html" class="button-link">Back to Dashboard</a>

  <script>
    window.addEventListener('load', async () => {
      try {
        await Clerk.load()

        if (!Clerk.user) {
          Clerk.redirectToSignIn({ redirectUrl: '/dev/auth/' })
          return
        }
      } catch (error) {
        window.location.href = '/dev'
      }
    });
  </script>

  <script type="module">
    import { Uppy, Dashboard, AwsS3, BasePlugin } from "https://releases.transloadit.com/uppy/v4.18.2/uppy.min.mjs"

    export default class VideoProcessor extends BasePlugin {
      constructor(uppy, opts = {}) {
        super(uppy, opts)
        this.id = opts.id || 'VideoValidator'
        this.type = 'modifier' // This modifies files before upload
        this.minDuration = opts.minDuration || 60
        this.aspectRatio = 16 / 9
        this.tolerance = opts.tolerance || 0.05
      }

      install() {
        this.uppy.on('file-added', this.validateFile.bind(this))
        this.uppy.on('restored', this.validateFile.bind(this))
      }

      uninstall() {
        this.uppy.off('file-added', this.validateFile.bind(this))
        this.uppy.off('restored', this.validateFile.bind(this))
      }

      async validateFile(file) {
        let isValid

        try {
          if (!file.type.startsWith('video/')) {
            return false
          }

          isValid = await new Promise((resolve) => {
            const video = document.createElement('video')
            video.preload = 'metadata'
            video.src = URL.createObjectURL(file.data)

            video.onloadedmetadata = () => {
              const duration = video.duration
              const ratio = video.videoWidth / video.videoHeight
              URL.revokeObjectURL(video.src)

              if (duration >= this.minDuration && Math.abs(ratio - this.aspectRatio) < this.tolerance) {
                this.uppy.setFileMeta(file.id, {
                  ...file.meta,
                  id: md5(Date.now() + '_' + file.name.replace(/\s+/g, '_')),
                  width: video.videoWidth,
                  height: video.videoHeight,
                  duration: Math.round(duration),
                  size: file.data.size
                })

                resolve(true)
              } else {
                resolve(false)
              }
            }

            video.onerror = () => {
              URL.revokeObjectURL(video.src)
              resolve(false)
            }
          })
        } catch (error) {
          console.error('Error validating video', error)
          isValid = false
        }

        if (!isValid) {
          this.uppy.info(`Video must be at least ${this.minDuration}s and 16:9 aspect ratio.`, 'error', 5000)
          this.uppy.removeFile(file.id)

          return false
        }
      }
    }

    window.addEventListener('load', async () => {
      let uid = (await window.cookieStore.get('uid')).value

      if (!uid) {
        throw new Error('Missing uid cookie')
      }

      // Helper: show status
      function showStatus(message, type = 'info') {
        const statusEl = document.getElementById('upload-status')
        if (statusEl) {
          statusEl.textContent = message
          statusEl.className = `upload-status ${type}`
          statusEl.style.display = 'block'
        }
      }

      function showError(message) {
        showStatus(message, 'error')
      }

      async function getUploadParameters(file) {
        const token = await Clerk.session.getToken()

        const res = await fetch('/api/upload?type=getUploadParameters', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ filename: file.name, contentType: file.type, id: file.meta.id })
        })

        const data = await res.json()

        if (!res.ok && data.code === 'UNACTIVATED_VIDEO') {
          alert('Please finish your existing video first. Redirecting...')
          window.location.href = `/dev/?v=${encodeURIComponent(data.details.videoId)}`
          throw new Error('Upload blocked: unfinished video exists')
        }

        return { method: 'PUT', url: data.url, headers: { 'Content-Type': file.type } }
      }

      async function createMultipartUpload(file) {
        const token = await Clerk.session.getToken()
        const res = await fetch('/api/upload?type=createMultipartUpload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ filename: file.name, contentType: file.type, id: file.meta.id })
        })

        const data = await res.json()

        if (!res.ok && data.code === 'UNACTIVATED_VIDEO') {
          alert('Please finish your existing video first. Redirecting...')
          window.location.href = `/dev/?v=${encodeURIComponent(data.details.videoId)}`
          throw new Error('Upload blocked: unfinished video exists')
        }

        return data
      }

      async function listParts(file, { uploadId, key }) {
        const token = await Clerk.session.getToken()
        const res = await fetch(`/api/upload?type=listParts&uploadId=${uploadId}&key=${encodeURIComponent(key)}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        })
        const data = await res.json()
        return data.parts || []
      }

      async function signPart(file, { uploadId, key, partNumber }) {
        const token = await Clerk.session.getToken()
        const res = await fetch(`/api/upload?type=getUploadPartURL&uploadId=${uploadId}&key=${encodeURIComponent(key)}&partNumber=${partNumber}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        })
        const data = await res.json()
        return { url: data.url }
      }

      async function completeMultipartUpload(file, { uploadId, key, parts }) {
        const token = await Clerk.session.getToken()
        const res = await fetch('/api/upload?type=completeMultipartUpload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ uploadId, key, parts })
        })
        return await res.json()
      }

      async function abortMultipartUpload(file, { uploadId, key }) {
        const token = await Clerk.session.getToken()
        await fetch('/api/upload?type=abortMultipartUpload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ uploadId, key })
        })
      }

      function handleUploadComplete(uppy) {
        return async function (result) {
          console.log('Upload complete!', result)

          if (result.failed?.length > 0) {
            showError(`Upload failed: ${result.failed[0].error?.message || 'Unknown error'}`)
            return
          }

          if (!result.successful?.length) {
            showError('No files uploaded.')
            return
          }

          const uploadedFile = result.successful[0]
          const meta = uploadedFile.meta
          const filename = uploadedFile.name
          const videoId = meta?.id
          const width = meta?.width || 0
          const height = meta?.height || 0
          const duration = meta?.duration || 0
          const size = meta?.size || 0

          const payload = { filename, width, height, size, duration, id: videoId }

          console.log('Sended payload', payload)
          try {
            const token = await Clerk.session.getToken()
            const resp = await fetch('/api/insert', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
              body: JSON.stringify(payload)
            })
            const json = await resp.json()
            if (json.success) {
              console.log('Upload result', json, json.document)
              showStatus('Upload and metadata saved! Redirecting...', 'success')
              setTimeout(() => {
                const idToOpen = videoId
                window.location.href = `/dev/?v=${encodeURIComponent(idToOpen)}`
              }, 900)
            } else {
              showError('Metadata save failed. Check server logs.')
            }
          } catch (err) {
            console.error(err)
            showError('Upload succeeded but saving metadata failed. Please try again later.')
          }
        }
      }

      // Initialize Uppy
      const uppy = new Uppy({
        autoProceed: false,
        restrictions: {
          allowedFileTypes: ['.mp4', '.MP4'],
          maxNumberOfFiles: 1,
          maxFileSize: 1771673011 // ~1.65GB
        },
        meta: { uid }
      })
        .use(Dashboard,
          {
            inline: true,
            target: '#uppy-container',
            note: 'Your video must be in MP4 format with a standard 16:9 aspect ratio, a minumum duration of 60 seconds and maximum file size of 1.65 GB. Only business-related content is permitted. Uploading duplicate or unrelated material will result in the suspension of your upload privileges.',
            locale: {
              strings: {
                dropPasteFiles: 'Drop video here or %{browse}'
              }
            }
          })
        .use(AwsS3, {
          shouldUseMultipart: (file) => file.size > 100 * 1024 * 1024,
          getChunkSize: (file) => 5 * 1024 * 1024,
          getUploadParameters,
          createMultipartUpload,
          listParts,
          signPart,
          completeMultipartUpload,
          abortMultipartUpload
        })
        .use(VideoProcessor, {})

      uppy.on('complete', handleUploadComplete(uppy))
      uppy.on('error', error => showError(error.message || 'Upload failed'))
    });
  </script>
</body>

</html>