<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bizilla TV - Upload</title>

  <!-- Uppy CSS -->
  <link href="https://releases.transloadit.com/uppy/v4.18.2/uppy.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/styles/upload.css">

  <!-- Clerk JS -->
  <script 
    async 
    crossorigin="anonymous" 
    data-clerk-publishable-key="pk_live_Y2xlcmsuc3luZGluZXQuY29tJA" 
    src="https://clerk.syndinet.com/npm/@clerk/clerk-js@5/dist/clerk.browser.js" 
    type="text/javascript">
  </script>


  <!-- Uppy JS -->
  <script type="module">
    import { Uppy, Dashboard, AwsS3 } from "https://releases.transloadit.com/uppy/v4.18.2/uppy.min.mjs";
    window.UppyModules = { Uppy, Dashboard, AwsS3 };
  </script>
</head>
<body>
  <h1>Upload a Video</h1>
  <p>Upload your video content to Bizilla TV. Supported formats include MP4, MOV, AVI, and more.</p>
  <div id="uppy-container"></div>
  
  <div id="upload-status" class="upload-status"></div>

  <!-- Navigation link styled as a button -->
  <a href="/dev/index.html" class="button-link">Back to Dashboard</a>

  <script>
    window.addEventListener('load', async () => {
      try {
        // Wait for Clerk to initialize
        await Clerk.load();

        // Correct way to check signed-in user
        const user = Clerk.user;
        if (!user) {
          alert("Please sign in first!");
          window.location.href = '/dev/index.html';
          return;
        }

        const userId = user.id; // Clerk user ID
        
        // Wait for Uppy modules to load
        while (!window.UppyModules) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Initialize Uppy using the imported modules
        const { Uppy, Dashboard, AwsS3 } = window.UppyModules;
        const uppy = new Uppy({
          autoProceed: false,
          restrictions: {
            allowedFileTypes: ['video/*'],
            maxNumberOfFiles: 1
          },
          meta: { user_id: userId }
        });

        uppy.use(Dashboard, {
          inline: true,
          target: '#uppy-container',
          note: 'Upload your video file.'
        });

        uppy.use(AwsS3, {
          shouldUseMultipart: (file) => file.size > 100 * 1024 * 1024,
          getChunkSize: (file) => 10 * 1024 * 1024, // 10MB chunks
          getUploadParameters: async (file) => {
            // This is required by Uppy even when using multipart
            // For small files that don't use multipart
            const token = await Clerk.session.getToken();
            const response = await fetch('/api/upload?type=getUploadParameters', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`,
                'X-User-Email': user.emailAddress
              },
              body: JSON.stringify({
                filename: file.name,
                contentType: file.type,
                key: file.name
              })
            });
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(`Failed to get upload parameters: ${errorData.error || response.statusText}`);
            }
            const data = await response.json();
            return {
              method: 'PUT',
              url: data.url,
              fields: {},
              headers: {
                'Content-Type': file.type
              }
            };
          },
          createMultipartUpload: async (file) => {
            const token = await Clerk.session.getToken();
            const response = await fetch('/api/upload?type=createMultipartUpload', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`,
                'X-User-Email': user.emailAddress
              },
              body: JSON.stringify({
                filename: file.name,
                contentType: file.type,
                key: file.name
              })
            });
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(`Failed to create multipart upload: ${errorData.error || response.statusText}`);
            }
            const data = await response.json();
            return {
              uploadId: data.uploadId,
              key: data.key
            };
          },
          listParts: async (file, { uploadId, key }) => {
            const token = await Clerk.session.getToken();
            const response = await fetch(`/api/upload?type=listParts&uploadId=${uploadId}&key=${encodeURIComponent(key)}`, {
              headers: {
                'Authorization': `Bearer ${token}`,
                'X-User-Email': user.emailAddress
              }
            });
            const data = await response.json();
            return data.parts || [];
          },
          signPart: async (file, { uploadId, key, partNumber }) => {
            const token = await Clerk.session.getToken();
            const response = await fetch(`/api/upload?type=getUploadPartURL&uploadId=${uploadId}&key=${encodeURIComponent(key)}&partNumber=${partNumber}`, {
              headers: {
                'Authorization': `Bearer ${token}`,
                'X-User-Email': user.emailAddress
              }
            });
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(`Failed to get upload URL: ${errorData.error || response.statusText}`);
            }
            const data = await response.json();
            return {
              url: data.url
            };
          },
          completeMultipartUpload: async (file, { uploadId, key, parts }) => {
            const token = await Clerk.session.getToken();
            const response = await fetch('/api/upload?type=completeMultipartUpload', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`,
                'X-User-Email': user.emailAddress
              },
              body: JSON.stringify({
                uploadId,
                key,
                parts
              })
            });
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(`Failed to complete upload: ${errorData.error || response.statusText}`);
            }
            const data = await response.json();
            return {
              location: data.location
            };
          },
          abortMultipartUpload: async (file, { uploadId, key }) => {
            const token = await Clerk.session.getToken();
            await fetch('/api/upload?type=abortMultipartUpload', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`,
                'X-User-Email': user.emailAddress
              },
              body: JSON.stringify({
                uploadId,
                key
              })
            });
          }
        });

        // Show upload progress
        uppy.on('upload-progress', (file, progress) => {
          const percent = Math.floor(progress.bytesUploaded / progress.bytesTotal * 100);
          const statusEl = document.getElementById('upload-status');
          statusEl.textContent = `Uploading: ${percent}% complete`;
          statusEl.style.display = 'block';
          statusEl.className = 'upload-status';
        });

        // Handle upload completion (both success and failure)
        uppy.on('complete', async (result) => {
          console.log('Upload complete! Successful:', result.successful, 'Failed:', result.failed);
          const statusEl = document.getElementById('upload-status');
          
          if (result.failed && result.failed.length > 0) {
            // There were failed uploads - show error and don't redirect
            const firstError = result.failed[0].error;
            statusEl.textContent = `Upload failed: ${firstError?.message || 'Unknown error'}`;
            statusEl.className = 'upload-status error';
            statusEl.style.display = 'block';
            console.error('Upload failed:', result.failed);
          } else if (result.successful && result.successful.length > 0) {
            // All uploads successful - insert metadata to Typesense
            statusEl.textContent = 'Upload complete! Processing video metadata...';
            statusEl.className = 'upload-status success';
            statusEl.style.display = 'block';
            
            const uploadedFile = result.successful[0];
            const file = uploadedFile.data;
            
            // Prepare metadata for Typesense (only essential fields)
            const videoMetadata = {
              id: generateVideoId(),
              filename: file.name,
              file_size: file.size,
              content_type: file.type,
              duration: 0 // Will be updated later when video is processed
            };
            
            try {
              // Insert video metadata to Typesense
              const response = await fetch('/api/insert', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${await Clerk.session.getToken()}`
                },
                body: JSON.stringify(videoMetadata)
              });
              
              const result = await response.json();
              
              if (result.success) {
                statusEl.textContent = 'Upload and processing complete! Redirecting...';
                // Redirect to video details page
                setTimeout(() => {
                  window.location.href = `/dev/?v=${videoMetadata.id}`;
                }, 1000);
              } else {
                throw new Error(result.error || 'Failed to process video metadata');
              }
            } catch (error) {
              console.error('Failed to insert video metadata:', error);
              statusEl.textContent = 'Upload successful but failed to process metadata. Please try again.';
              statusEl.className = 'upload-status error';
              
              // Still redirect to dashboard after a delay
              setTimeout(() => {
                window.location.href = '/dev/';
              }, 3000);
            }
          } else {
            // No files processed
            statusEl.textContent = 'No files were uploaded.';
            statusEl.className = 'upload-status error';
            statusEl.style.display = 'block';
          }
        });
        
        // Function to generate a unique video ID
        function generateVideoId() {
          return 'vid_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        // Handle upload errors
        uppy.on('error', (error) => {
          console.error('Upload error:', error);
          const statusEl = document.getElementById('upload-status');
          statusEl.textContent = `Error: ${error.message || 'Upload failed'}`;
          statusEl.className = 'upload-status error';
          statusEl.style.display = 'block';
        });

      } catch (err) {
        console.error("Error initializing upload page:", err);
        const statusEl = document.getElementById('upload-status');
        statusEl.textContent = `Error: ${err.message || 'Failed to initialize uploader'}`;
        statusEl.className = 'upload-status error';
        statusEl.style.display = 'block';
      }
    });
  </script>
</body>
</html>